/*
Paly Astrophysics Sun/Planet tracking
*/


// cleanup
LabelMgr.deleteAllLabels();
HighlightMgr.cleanHighlightList();

// color constants
var POS_COLOR = "#ffaa00"
var OBJ_COLOR = "#ffffff"
var CON_COLOR = "#ffffff"

// abbreviation definitions
var iauNames = {
  "Ari": "Aries",
  "Tau": "Taurus",
  "Gem": "Gemini",
  "Cnc": "Cancer",
  "Leo": "Leo",
  "Vir": "Virgo",
  "Lib": "Libra",
  "Sco": "Scorpius",
  "Sgr": "Sagittarius",
  "Cap": "Capricornus",
  "Aqr": "Aquarius",
  "Psc": "Pisces",
  "Oph": "Ophiuchus"
};

// J2000 ecliptic longitudes
var eclon = {
  "Psc": 28.687,
  "Ari": 53.417,
  "Tau": 90.140,
  "Gem": 117.988,
  "Cnc": 138.038,
  "Leo": 173.851,
  "Vir": 217.810,
  "Lib": 241.047,
  "Sco": 247.638,
  "Oph": 266.238,
  "Sgr": 299.656,
  "Cap": 327.488,
  "Aqr": 351.650
};

// coordinate conversion functions
function degToHMS(deg) {
  var totalHours = deg / 15.0;
  var hours = Math.floor(totalHours);
  var totalMinutes = (totalHours - hours) * 60;
  var minutes = Math.floor(totalMinutes);
  var seconds = Math.floor((totalMinutes - minutes) * 60);
  return hours + "h" + minutes + "m" + seconds + "s";
}
function degToDMS(deg) {
  var sign = (deg >= 0) ? "+" : "-";
  deg = Math.abs(deg);
  var degrees = Math.floor(deg);
  var totalMinutes = (deg - degrees) * 60;
  var minutes = Math.floor(totalMinutes);
  var seconds = Math.floor((totalMinutes - minutes) * 60);
  return sign + degrees + "d" + minutes + "m" + seconds + "s";
}

// constellation bounds (RA/Dec) as decimal
var boundsRaDec = {
  "Psc": [24.9, 11.15], 
  "Ari": [49.25, 18.73],
  "Tau": [88.39, 23.430],
  "Gem": [118.29, 20.51], 
  "Cnc": [138.68, 15.33],
  "Leo": [172.55, 2.3],
  "Vir": [213.67, -14.2],
  "Lib": [237.15, -20.45],
  "Sco": [244.1, -21.63],
  "Oph": [264.15, -23.39],
  "Sgr": [300.04, -20.15],
  "Cap": [327.9, -12.19],
  "Aqr": [350.55, -3.21]
};

var SHIFT_DEG = -2.15;

// debug: highlights on boundaries
for (var key in boundsRaDec) {
    if (boundsRaDec.hasOwnProperty(key)) {
        var coords = boundsRaDec[key];
        var raDeg = coords[0];
        var decDeg = coords[1];
        raDeg -= SHIFT_DEG;
        boundsRaDec[key][0] -= SHIFT_DEG;
        if (raDeg < 0) {
            raDeg += 360;
        }
        var raStr  = degToHMS(raDeg);
        var decStr = degToDMS(decDeg);
        HighlightMgr.addPointRaDec(raStr, decStr);
    }
}

var counter = 200; //label positioning
function label(text, x_offset, size, color) {
    LabelMgr.labelScreen(text, 300 + x_offset, counter, true, size, color);
    counter += 20;
}

function parseTime(timeStr) {
    const match = timeStr.match(/(\d+)h(\d+)m/);
    const hours = parseInt(match[1], 10);
    const minutes = parseInt(match[2], 10);
    return hours * 60 + minutes; 
}
function formatTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours}h${mins}m`;
}
function calculateDayLength(riseTime, setTime) {
    const riseMinutes = parseTime(riseTime);
    const setMinutes = parseTime(setTime);
    const dayLengthMinutes = setMinutes - riseMinutes;
    return formatTime(dayLengthMinutes);
}

// mega nerd math that i barely understand
// Convert equatorial (RA, Dec in degrees) to ecliptic longitude (degrees)
function equatorialToEcliptic(raDeg, decDeg) {
    // Correct obliquity of the ecliptic for J2000.0
    var epsilon = 23.4392911 * Math.PI/180;
    
    // Convert RA and Dec to radians
    var raRad = raDeg * Math.PI/180;
    var decRad = decDeg * Math.PI/180;
    
    // Calculate ecliptic longitude 
    var sinLambda = Math.sin(raRad) * Math.cos(epsilon) + Math.tan(decRad) * Math.sin(epsilon);
    var cosLambda = Math.cos(raRad);
    var lambdaRad = Math.atan2(sinLambda, cosLambda);
    
    // Convert back to degrees and ensure the value is in [0, 360)
    var lambdaDeg = lambdaRad * 180/Math.PI;
    if (lambdaDeg < 0) {
        lambdaDeg += 360;
    }
    
    return lambdaDeg;
}

// Build sorted boundary array from eclon (by increasing longitude)
var sortedBoundaries = [];
for (var key in eclon) {
    if (eclon.hasOwnProperty(key)) {
         sortedBoundaries.push({ key: key, lon: eclon[key] });
    }
}
sortedBoundaries.sort(function(a, b) { return a.lon - b.lon; });

// Given an object's ecliptic longitude L, determine the two adjacent boundaries
// and calculate how many degrees above the lower and below the upper boundary it is.
function getBoundaryDistances(L) {
    // Ensure L is within [0, 360)
    while (L < 0) L += 360;
    while (L >= 360) L -= 360;
    
    var lowerBoundary, upperBoundary, lowerKey, upperKey, distLower, distUpper;
    
    // Handle case where L is before the first boundary or after the last boundary
    if (L < sortedBoundaries[0].lon) {
        // Object is between the last and first boundaries, wrapping around 0°
        lowerBoundary = sortedBoundaries[sortedBoundaries.length - 1].lon;
        lowerKey = sortedBoundaries[sortedBoundaries.length - 1].key;
        upperBoundary = sortedBoundaries[0].lon;
        upperKey = sortedBoundaries[0].key;
        
        // Calculate distances correctly handling the wrapping at 360°
        distLower = (L + 360) - lowerBoundary;
        if (distLower >= 360) distLower -= 360;
        
        distUpper = upperBoundary - L;
        if (distUpper < 0) distUpper += 360;
    } 
    else if (L >= sortedBoundaries[sortedBoundaries.length - 1].lon) {
        // Object is between the last and first boundaries
        lowerBoundary = sortedBoundaries[sortedBoundaries.length - 1].lon;
        lowerKey = sortedBoundaries[sortedBoundaries.length - 1].key;
        upperBoundary = sortedBoundaries[0].lon + 360; // Add 360 to handle the wrapping
        upperKey = sortedBoundaries[0].key;
        
        distLower = L - lowerBoundary;
        distUpper = upperBoundary - L;
    }
    else {
        // Find the two boundaries that the object is between
        for (var i = 0; i < sortedBoundaries.length - 1; i++) {
            if (L >= sortedBoundaries[i].lon && L < sortedBoundaries[i+1].lon) {
                lowerBoundary = sortedBoundaries[i].lon;
                lowerKey = sortedBoundaries[i].key;
                upperBoundary = sortedBoundaries[i+1].lon;
                upperKey = sortedBoundaries[i+1].key;
                
                distLower = L - lowerBoundary;
                distUpper = upperBoundary - L;
                break;
            }
        }
    }
    
    return {
        lowerKey: lowerKey,
        upperKey: upperKey,
        distLower: distLower,
        distUpper: distUpper,
        totalWidth: distLower + distUpper
    };
}

function getSymbolView(distLower, distUpper) {
    var total = distLower + distUpper;
    
    if (total <= 0) return "|    |    |    |    |";
    
    // Calculate the relative position of the object between boundaries
    var fraction = distLower / total;
    
    var positions = 20;
    var dotPosition = Math.round(fraction * positions);
    
    // Ensure dotPosition is within valid range
    if (dotPosition < 0) dotPosition = 0;
    if (dotPosition > positions) dotPosition = positions;
    
    var result = "";
    for (var i = 0; i <= positions; i++) {
        if (i % 5 === 0) {
            result += "|"; // Boundary marker
        } else if (i === dotPosition) {
            result += "•"; // Object position
        } else {
            result += " "; 
        }
    }
    
    return result;
}


// Sun labels
var sun = core.selectObjectByName("Sun", false);
var sunInfo = core.getSelectedObjectInfo(sun);
core.debug(JSON.stringify(sunInfo));
label(sunInfo.name, 0, 20, OBJ_COLOR);
label("Rise: " + sunInfo.rise, 20, 18, OBJ_COLOR);
label("Set: " + sunInfo.set, 20, 18, OBJ_COLOR);
label("Day: " + calculateDayLength(sunInfo.rise, sunInfo.set), 20, 18, OBJ_COLOR);
label(iauNames[sunInfo.iauConstellation], 20, 18, CON_COLOR);

var sunEclLon = equatorialToEcliptic(sunInfo.ra, sunInfo.dec);
var sunBoundaries = getBoundaryDistances(sunEclLon);
var sunSymbol = getSymbolView(sunBoundaries.distLower, sunBoundaries.distUpper);
core.debug("Sun ecliptic longitude: " + sunEclLon.toFixed(2) + "°");
core.debug("Sun is " + sunBoundaries.distLower.toFixed(2) + "° above the lower boundary (" + sunBoundaries.lowerKey + ")");
core.debug("Sun is " + sunBoundaries.distUpper.toFixed(2) + "° below the upper boundary (" + sunBoundaries.upperKey + ")");
core.debug("Sun symbol view: " + sunSymbol);
label(sunSymbol, 20, 18, POS_COLOR);

// Planet labels
var objects = SolarSystem.getObjectsList("planet");
var planets = ["Mercury", "Venus", "Mars", "Jupiter", "Saturn"];
objects.forEach(item => {
    if (planets.indexOf(item) > -1) { 
        var sel = core.selectObjectByName(item, false);
        var objectInfo = core.getSelectedObjectInfo(sel);
        label(objectInfo.name, 0, 20, OBJ_COLOR);
        var constellationName = iauNames[objectInfo.iauConstellation];
        label(constellationName, 20, 18, CON_COLOR);
        var planetEclLon = equatorialToEcliptic(objectInfo.ra, objectInfo.dec);
        var planetBoundaries = getBoundaryDistances(planetEclLon);
        var planetSymbol = getSymbolView(planetBoundaries.distLower, planetBoundaries.distUpper);
        core.debug(objectInfo.name + " ecliptic longitude: " + planetEclLon.toFixed(2) + "°");
        core.debug(objectInfo.name + " is " + planetBoundaries.distLower.toFixed(2) + "° above the lower boundary (" + planetBoundaries.lowerKey + ")");
        core.debug(objectInfo.name + " is " + planetBoundaries.distUpper.toFixed(2) + "° below the upper boundary (" + planetBoundaries.upperKey + ")");
        core.debug(objectInfo.name + " symbol view: " + planetSymbol);
        label(planetSymbol, 20, 18, POS_COLOR);
    }
});
